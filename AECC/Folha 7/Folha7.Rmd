---
title: "Análise de Componentes Principais (ACP)"
author: ""
date: "`r format(Sys.Date(), '%d %B %Y')`"
output:
  html_document:
 #   toc: true
  #  toc_depth: 2
  #  number_sections: true
  pdf_document:
  #  toc: true
   # number_sections: true
lang: pt
fontsize: 11pt
geometry: margin=2.5cm
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
set.seed(123)
```

```{r E0}
library(ISLR2)
library(mlbench)
library(pls)
library(ggplot2)
library(dplyr)
library(tibble)
```
# Exercício 1 — NCI60 (expressão génica; p ≈ 6.830)

**Dados**: `ISLR2::NCI60` (64 linhas = linhas celulares; ~6.830 genes como variáveis).

1. Use a library `ISLR2` e obtenha a matriz `NCI60$data`. Quantas variáveis (genes) existem? Há valores em falta?
```{r E1}
X_raw <- NCI60$data
labs <- NCI60$labs
n <- nrow(X_raw); p <- ncol(X_raw)

na_total <- sum(is.na(X_raw))
list(n_obs = n, p_variaveis = p, faltantes_total = na_total)

```

2. Construa `X <- scale(NCI60$data)` (centrar e padronizar por coluna). Justifique a escolha de **correlações** em vez de **covariâncias** neste contexto.
```{r E2}
X <- scale(NCI60$data)

summ <- as_tibble(X) %>%
  summarise(across(everything(), list(media = ~mean(.x), sd = ~sd(.x))))

```

3. Aplique `prcomp` a `X` (não volte a padronizar dentro de `prcomp`). Extraia **valores próprios**, **PVE** e **PVE acumulada**. Faça o **scree plot** e o gráfico da PVE acumulada.
```{r E3}
pc_nci <- prcomp(X, center = FALSE, scale = FALSE)

ev <- pc_nci$sdev^2
pve <- ev / sum(ev)
cpve <- cumsum(pve)

resumo_pve <- tibble(
  CP = seq_along(ev),
  autovalor = ev, 
  PVE = pve,
  PVE_acumulada = cpve
) %>%
  slice(1:15)

resumo_pve

qplot(y = ev, x = seq_along(ev), geom = c("line", "point")) +
  labs(x = "Componente", y = "Autovalor", title = "NCI60 - Scree Plot") +
  theme_minimal()

qplot(y = cpve, x = seq_along(cpve), geom = c("line","point")) +
  labs(x = "Componente", y = "PVE acumulada", title = "NCI60 — PVE acumulada") +
  theme_minimal()
  
```

4. Faça um gráfico **CP1 vs CP2** dos *scores*. Use `NCI60$labs` apenas para **colorir** os pontos por tipo de cancro (não entra na ACP). Comente padrões/separações.
```{r E4}
Scores <- as_tibble(pc_nci$x[,1:2], .name_repair = "minimal") %>%
  mutate(tipo = labs)

colnames(Scores)[1:2] <- c("CP1","CP2")

Scores$tipo <- factor(Scores$tipo)

ggplot(Scores, aes(x = CP1, y = CP2, color = tipo)) +
  geom_point(size = 2, alpha = 0.9) +
  labs(title = "NCI60 - Scores CP1 vs CP2", color = "Tipo") + 
  theme_minimal()

```

5. Identifique os **25 genes** com maiores |loadings| em **CP1** e em **CP2** (duas listas). Discuta se há sobreposição entre as listas.
```{r E5}
load <- pc_nci$rotation
ord1 <- order(abs(load[,1]), decreasing = TRUE)[1:25]
ord2 <- order(abs(load[,2]), decreasing = TRUE)[1:25]
Top_CP1 <- tibble(
  gene = colnames(X_raw)[ord1], 
  loading = load[ord1,1]
)
Top_CP2 <- tibble(
  gene = colnames(X_raw)[ord2],
  loading = load[ord2,2]
)
list(Top25_CP1 = Top_CP1,
     Top25_CP2 = Top_CP2,
     sobreposicao = length(interaction(Top_CP1$gene, Top_CP2$gene))
)

```

---

# Exercício 2 — Sonar (sinais; p = 60)

**Dados**: `mlbench::Sonar` (208 amostras, 60 variáveis de energia em bandas de frequência; classe M/R usada **apenas** para visualização).

1. Carregue `mlbench` e prepare `X <- scale(as.matrix(Sonar[, 1:60]))`. Guarde o vetor de classes `y <- Sonar$Class`.
```{r E6}
data(Sonar)

X_sonar <- scale(as.matrix(Sonar[,1:60]))
y_sonar <- Sonar$Class
c(dim(X_sonar), classes = levels(y_sonar)) #Mostrar apenas

```

2. Aplique ACP a `X`. Reporte **PVE** e **PVE acumulada**; produza o **scree plot**.
```{r E7}
pc_sonar <- prcomp(X_sonar, center = FALSE)
ev2 <- pc_sonar$sdev^2
pve2 <- ev2 / sum(ev2)
cpve2 <- cumsum(pve2)
head(tibble(
  CP = 1:10, 
  PVE = pve2[1:10], 
  PVE_ACUM = cpve2[1:10]
))

qplot(y = ev2, x = seq_along(ev2), geom = c("line","point")) +
  labs(x = "Componente", y = "Autovalor", title = "Sonar - Sree Plot") +
  theme_minimal()

```

3. Faça um gráfico **CP1 vs CP2** com pontos coloridos por `y`. Comente se há **separação** entre M (mine) e R (rock).
```{r E8}
sc2 <- tibble(pc_sonar$x[,1:2]) %>%
  mutate(Class = y_sonar)
colnames(sc2)[1:2] <- c("CP1","CP2")

ggplot(sc2, aes(x = CP1[,"PC1"], y = CP1[,"PC2"], color = CP2)) +
  geom_point(size = 2) + 
  labs(title = "Sonar - Scores CP1 vs CP2") +
  theme_minimal()

```

4. Mostre um **biplot** (atenção à escala visual). Quais as **5 variáveis** com maior |loading| em CP1 e CP2?

```{r E9}
biplot(pc_sonar, scale = 0)

load2 <- pc_sonar$rotation
Top5_CP1 <- tibble(var = colnames(Sonar)[1:60][order(abs(load2[,1]), decreasing = TRUE)[1:5]],
                   loading = load2[order(abs(load2[,1]), decreasing = TRUE)[1:5],1])
Top5_CP2 <- tibble(var = colnames(Sonar)[1:60][order(abs(load2[,2]), decreasing = TRUE)[1:5]],
                   loading = load2[order(abs(load2[,2]), decreasing = TRUE)[1:5],2])

list(Top5_CP1 = Top5_CP1,
     Top5_CP2 = Top5_CP2)

```

---

# Exercício 3 — Espectroscopia NIR (*yarn*; p ≈ 268 comprimentos de onda)

**Dados**: `pls::yarn`. Tem espectros NIR (muitas variáveis) e respostas químicas (ex.: `density`). Use **apenas** os **espectros** para ACP.

1. Carregue `pls` e examine `yarn`. Construa a matriz `X <- scale(yarn$NIR)` com padronização por coluna.
```{r E10}
X_yarn <- scale(yarn$NIR) 

```

2. Aplique ACP a `X`. Reporte **valores próprios**, **PVE** e **PVE acumulada**. Produza os gráficos correspondentes.
```{r E11}
pc_yarn <- prcomp(X_yarn, center = FALSE)
ev3  <- pc_yarn$sdev^2
pve3 <- ev3 / sum(ev3)
cpve3 <- cumsum(pve3)

head(tibble(
  CP = 1:10,
  PVE = pve3[1:10],
  PVE_ACUM = cpve3[1:10]
))

qplot(y = ev3, x = seq_along(ev3), geom = c("line", "point")) +
  labs(x = "Componente", y = "Autovalor", title = "yarn - Sree Plot") +
  theme_minimal()

qplot(y = cpve3, x = seq_along(cpve3), geom = c("line", "point")) +
  labs(x = "Componente", y = "Autovalor", title = "yarn - PVE Acumulada") +
  theme_minimal()

```

3. Faça **scores plots** (CP1 vs CP2, e CP2 vs CP3). Procure padrões (e.g., batches/lotes se disponíveis).
```{r E12}
sc3 <- as_tibble(pc_yarn$x[,1:3])
colnames(sc3) <- c("CP1","CP2","CP3")

g1 <- ggplot(sc3, aes(CP1, CP2)) +
  geom_point(size  = 1) +
  labs(title = "yarn - Scores CP1 vs CP2") +
  theme_minimal()

g2 <- ggplot(sc3, aes(CP2, CP3)) +
  geom_point(size  = 1) +
  labs(title = "yarn - Scores CP2 vs CP3") +
  theme_minimal()

```

4. Identifique **intervalos de onda** com maiores contribuições (|loadings| altos) para CP1 e CP2. Discuta possível interpretação.

```{r E13}
load3 <- pc_yarn$rotation
idx1 <- order(abs(load3[,1]), decreasing = TRUE)[1:15]
idx2 <- order(abs(load3[,2]), decreasing = TRUE)[1:15]
TopBand_CP1 <- tibble(indice_onda = idx1, loading = load3[idx1,1])
TopBand_CP2 <- tibble(indice_onda = idx2, loading = load3[idx2,2])

list(TopBand_CP1 = TopBand_CP1,
     TopBand_CP2 = TopBand_CP2)

```

---
